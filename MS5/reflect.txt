/* Citation and Sources...
Final Project Milestone
Filename: 	reflect.txt
Version 1.0
Author	CJ Jingren Tong
Revision History
-----------------------------------------------------------
Date        		Reason
2021/03/08  	Milestone 1 Completion (Time & Utils Module)
2021/03/09  	Update getcstr function without using string class
2021/03/18  	Milestone 2 Completion (Menu Module & IOAble interface module)
2021/03/19  	Walk through IOAble tester
2021/03/23  	Milestone 3 (Patient Module implementation -- abstract IOAble patient class)
2021/03/23  	Error checking with Patient tester that I have created. Modified condition inside of the getcstr function within utils module
2021/03/24  	Error checking with FileIO tester that I have created. Modified csvRead() method inside of the Patient module.
		Because the file we are reading from contains the 6th line, or any files we would need to read from contains a
		blank line at the end. We should stop reading the line if there is nothing within the line.
2021/03/24  	Walked through Milestone 3 with ms3Tester.cpp
2021/03/27	Milestone 4 (CovidPatient and TriagePatient module implementation)
		Unit testing each modules, and walked through ms4Tester.
2021/03/29	Added function template removeDynamicElement into the utils.h file.
		Completed PreTriage constuctor, destructor, load(), making sure data filename being set dynamically and safely. Also made sure
		Patient records are imported from the data file correctly by using the load().
		Making sure data file is able to overwrite/write to the datafile correctly, and being allocated memory being deallocated safely
		by using the destructor.
2021/03/30	Implemented reg(), getWaitTime() function, used unit testing method to test the functions
2021/03/30	Implemented admit(), indexOfFirstInLine(), removePatientFromLineup() and setAverageWaitTime(), used unit testing method to test
		the functions
2021/04/01	Implemented run(), used fp1Tester to test with new(non-existent) data file
2021/04/02	Used fp2Tester to test small data file, fp3Tester to test big data file. And fpTester that is combined with all three testers.
		Edited some line breaks and output formats.
2021/04/04	Completed reflection for Final project
-----------------------------------------------------------
I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.
-----------------------------------------------------------*/

Reflection: 
Introduction: 
The project that I have done is to implement a pre-triage application for hospital. With this program, I am able to register patients for different purposes (Covid or Triage) by getting patients name and OHIP number, provide up to date estimate waiting time for the patient, admit next patient based their category, data can be written and extracted from the patient datafile with the corresponding format. The project has included all the topics that I have learned throughout the semester. Milestone instructions have provided clear and extremely helpful implementation orders, logic and knowledge that helped me complete the General Hospital Pre-Triage Application project. This project is a great example of encapsulation, inheritance and polymorphism, which are the main concept and cornerstones of object programming language. Throughout the semester, I have learned the multi-paradigm language like C++ is very close to human way of thoughts. It has introduced us the encapsulated structure that contains attributes and methods, which the actions belong to the owners. The following is lists of concepts that have helped me complete the project, which have helped me to consolidate the learned knowledge through the completion.

Milestone 1: 
The first milestone includes two modules, which are utils and Time. They are the helper modules which able to get fool-proof entry from users, read and write time values, and calculate time by doing arithmetic operations. 
I have used the knowledge that I have learned about extracting data from the input device correctly and dynamic allocating memory based on the user input inside of the utils module. The functions that I have implemented were extremely useful later on in the program. The implemented getTime function is able to prompt user for correct format current time or getting the local time, then returned time in minutes format. With getInt function, I am able to get a fool-proof integer entry from the console with corresponding prompt message or symbols. Conditions inside of the functions able to accept safe input without overflow. Another overloaded getInt function able to accept 5 arguments, which able to get the integer input within range; and if entry invalid, the error message being passed through argument able to be displayed if it is not null. The getInt Tester is very helpful to provide unit checking during implementation, which avoid future data inserting errors. 
I have completed the optional challenge for the getcstr function that able to implement this function without using the C++ string class. I have used the knowledge that I have learned about dynamic allocation and memory resizing to complete this function. Also, I have used some member function that being supported by istream, to ignore/discard characters, extract characters from the input buffer. I have dynamically allocated an array which can accept up to 100 characters. If the user input is more than 100 characters, we are able to allocate another 100 characters, and this whole process is going by iterations, characters will be getting resized by 100 each time if needed. The cstring is able to store the user input based on the characters being accepted up to the delimiter and memory will get allocated accordingly. If memory needs to be resized, the content will be stored inside of the function scope variable temp, and get copied into the cstring. Now cstring will be pointing to the same data as temp is pointing to, and what remaining in cstring is having a newly sized memory. By allocating and copying based on cstring, we will be able to return the dynamically allocated memory. 
For Time module, I am able to initialize time, set time, read time from istream object and write time to ostream object with format. There are all types of basic arithmetic operations on Time that have been implemented in this module. They are used to calculate time differences, setting time value, adding, multiplying, dividing, casting Time object for different purposes based on a 24-hour clock. Time arithmetic operations are very helpful in terms of setting arrival time, or calculating waiting time for patients. We have put in consideration of operations with or without side effect, which gives us control of if we want to modify the current object through the operation; also, casting to an integer or unsigned int, which is also very useful in terms of able to get the numbers of minutes with casting to either of them. Sometimes, in the program, if we want to set the minutes to an unsigned int instead of int, we are able to cast the Time object to either of them based on the variables we will be using at the situation. Also, the two helper operations, which are the overloaded insertion and extraction operator, I am able to insert a Time object into an ostream object or extract data from an istream object into the Time object. 
I have found those two modules above can be very useful, even in terms of other programmers able to use those modules inside of their own programs. They are highly cohesive within its class and loosely coupled between the class’ implementation and any one of its clients. 

Milestone 2: 
For Milestone 2, I have implemented Menu and IOAble modules, they are very important in terms of building the structure for the assignment as a whole. They have introduced us the functionality of the program, which we are able to make selection from the menu being displayed; and creating an interface, which is an access to the derived classes and promotes low coupling between client code and an object’s class hierarchy. 
First, within the Menu module, it is a class that encapsulates the data member, a dynamically allocated menu, and the member functions. which is the selection functionality for the caller program. We are able to display the menu that have been dynamically allocated, store the numbers of selections based on the menu we have, copy the Menu safely, and fool-proof the selection entry. I have added methods like setContent, deallocate, which allows me to allocate for the menu content safely. Also, for my two argument constructors and copy constructors, I have initialized the members with default constructor to make sure that the object is being created at a safe empty state at all times. 
Because Menu is a class that contains resource that is outside of its own scope, like the dynamic memory allocation for the menu content, I have created copy constructor and copy assignment operator to make sure that we do not have memory leak. I have put '=delete' signature for the copying assignment operator, to let the compiler know, no copy assignment is supposed to happen, which prevent assignment copying. But I have implemented copying constructor, to make sure we can create a new Menu out of another Menu object, let the data able to be safely copied to another object with the same type, as soon as when the Menu object gets created. We do not want the program taking over by doing blind copying, which will cause memory leak issues when it is involving with resource and data outside of its class. The Rule of Three is being included in the Menu module, because we are holding resources outside of its scope, to prevent bad copying that can be caused by passing arguments by value or returning an object by value, which leads to memory leak and destructor crash issues. 
The extraction operator will display the menu and also receives the user's selection as integer value using the getInt that we have implemented inside of the utils module, which made sure the selection is been validated. 
For the IOAble interface module, it is used to enforce input and output methods to its derived classes. Pure function is the principal components of an abstract base class. Inside of IOAble class, we do not have any data members and only pure virtual functions, which makes this abstract base class a pure interface. This class becomes only an idea because it contains at least one pure virtual function, it cannot be materialized until we inherited into a new class and implemented all the functions that is incomplete and pure virtual. We are not able to create an IOAble object in the main file, whenever if we want to enforce an idea to be implemented later, there are actions like csvWrite, csvRead, write and read, we want those actions that is going to be inherited by its derived classes objects, we would want to enforce those class which actually implementing the action further, and need to improve from the base class. I have added the insertion and extraction helper function to make the IOAble printable and readable. For both of their parameter, it has IOAble reference, which is the reference of Patient, Ticket, or even the reference of CovidPatient and TriagePatient, the compiler would be able to go to the latest version of write and read which been implemented inside of the helper functions. 
Virtual functions are being included inside of this module which greatly shown the inclusion polymorphism characteristics of the object-oriented language, which refers to the multiplicity of logic that associate with the same action. I have made sure the destructor in the base class IOAble is virtual, because we want the latest destructor in hierarchy of inheritance to be called, it guarantees if the class is inherited, no memory leak will happen no matter how we create or referring to the class, that is why I also set the class to virtual as in consideration for other developers might try to refer to this code. It would make sure it would be able to remove the derived parts of the object before the base part of the object getting removed. If the action is being improved, the compiler would need to call the improved version. Virtual is telling the compiler to execute the latest version of this action. 
Inside of the Milestone 2 instruction, it has included a hierarchy diagram about the classes, which helps me understood the relationship between them. IOAble is the interface, which makes sure that the client code does not have any access to the variety of implementations available within the hierarchy, also, the implementation code has no access to the client codes that use the hierarchy. Patient and Ticket are derived class of the interface IOAble, CovidPatient and TriagePatient are the derived class of their parent class Patient. The actions that able to output comma separated data, accepting comma separated input, write ostream outputs and read istream input, are being forced to be improved later on in its derived classes. The IOAble tester program fully demonstrate how the IOAble module works and demonstrate how an interface is used as a base class. We are able to see how we are dynamically allocating object, getting information from console, display to the console, or reading and displaying information from file and writing or saving data to file. The concept that I have learned in this tester has helped me a lot from implementing some functionalities in Milestone 5. 

Milestone 3: 
For Milestone 3, we have implemented two derived classes, Patient and Ticket, that have publicly inherited from the base class IOAble, which we have just implemented. By completing those two modules, which helped me have a better understanding about the inheritance characteristic in the object-oriented programming language like C++. It has help to implement reusability in the coding structures. It allows us to utilize existing information, one class inherited the entire structure of another class, and only provide code that can implement additional structure. Implementation also proves the fact of inheritance is a transitive structural relationship, and it is not commutative. The class lower in the hierarchy like Patient and Ticket, is a kind of the class that is higher in the hierarchy, which in this case will be the IOAble.
Member functions like csvWrite, csvRead, write and read within those two classes are being implemented. 
First is the Ticket module which includes actions like issuing ticket to the patients when they arrive, it contains private member variables like Time object, which stores the time when the Ticket was issued, it can be created based on the Time module we have implemented in Milestone 1, also, it contains the ticket sequential number that uniquely identify each patient’s ticket number. Also, we are able to create ticket with numbers, converting Ticket object to time, so we are able to get the arrival time of the patient, getting the ticket number, set the ticket time to the current time, and all the pure virtual function overwrites, that output comma-separated ticket number and time by inserting to ostream, extracting the ticket number and time from the input stream, inserting the ticket into the ostream object to be displayed on console, and also extracting the ticket information from the istream object. The helper functions from the IOAble do not directly support classes derived from the supported base class, however, because the parameter able to accept IOAble reference which I have explained before, which now, we are able to use the operation this way. 
For the Patient module, this class is still an abstract base class after being derived from the IOAble interface, because it contains another pure virtual function type () which would need to be implemented inside of the child classes that is inherited from it. This class is responsible to encapsulate a general patient arriving at the hospital. It contains all the basic information about a patient. We have dynamically allocated patient name, his/her OHIP number, the Ticket object which includes information about the ticket number, and issued time, and the file flag to determine if we are written into or read from a file or the console. I have added functions like deallocate and setName with the same purpose as I did inside of the Menu module, to help me safely allocating and deallocating patient’s names. I have also included the rule of three in this module, because it contains recourses outside of the class. But to make sure that a patient cannot be copied or assigned to another patient, we have added the 'delete' signature for both of the copying assignment and copying constructors. We have the == operator overloads operations that able to use compare characters based on the Patient types, or comparing patient types with another patient. The pure virtual function type which able to help us determine the type of the patient in the derived class that is inherited from this Patient class. We have included csvWrite, csvRead, write and read pure virtual function overwrites in this module as well, so we are able to insert data to the ostream of patient and ticket information, getting patient information, ticket time and number information from the istream object, also, to insert the information into the ostream object to be displayed on the console, and to extract the ticket information from the istream object from the console. I have included utils module again in my implementation, the getInt function is allowing me to get the Patient’s OHIP number with the fool-proofed format, and provide corresponding error message. Also, I am able to get the name from the istream object dynamically and safely by using the implementation of the getcstr function. It really improves the reusability of the program. 
The tester for the milestone gave us a preview of class being inherited from the Patient, and how the functionality works based on that. We have derived class object being created as a pointer or reference of the parent, Patient. Virtuality is taking a huge role in terms of the latest version of the methods will then be called. Now compiler is capable to call the method of the object that the pointer is pointing to, and not just the pointer part of the object. Also, the tester has demonstrated to us again about how to read and write from and to a file object or console properly. It has strengthened my understanding of this functionality for the future file-based implementations. 

Milestone 4: 
For Milestone 4, we will be focusing on implementing CovidPatient and TriagePatient concerte classes which are the derived classes of Patient class. The patient now is more categorized, and we will now be able to register or admit patients, getting waiting time, based on the types. This has made the program more functional and organized.  Both modules contain similar structure, and they both contains a global variable which determine the ticket number based on the type of the patient, and this variable is only available in its own module. 
First, it is the CovidPatient module, it contains all the functionality and data members of its own, and also the public functionality that has been inherited from its parent class, Patient. The global variable nextCovidTicket is used to determine the sequential ticket number of the next Covid test patient. The scope of this global variable is class scope which is only able to be accessed within the CovidPatient module. I have overwritten the type pure virtual function from the base class, which will return the character C which is the identification of the Patient type. The default constructor inside of the CovidPatient class will set the Ticket number to the current global value and then increase the global value by one. In the initialization area, I have used the Patient one argument constructor which able to pass in incremented ticket number as parameter, and initialize the CovidPatient object to a safe empty state for all data members except its ticket number. csvWrite function will be inherit from its parent class, but we have implemented csvRead function, which will first call the csvRead inside of the Patient class, it will extract the patient and ticket information from istream object, but we have improved this action because we also able to increment and provide covid ticket number within this function. For read method, we are able to either read from a file or the console. If the fileIO returns true, it will call the csvRead function of the same class; and if the fileIO returns false, it will call the read function of its parent class Patient, which will extract the ticket information from the console using istream object. Similar to write method, we are able to either write/overwrite to the file or output to the console. By checking the fileFlag, when it is true, it will be calling the csvWrite that is inside of its parent class Patient to inserts the Patient data and ticket information into ostream object in a comma-separated format; however, when fileFlag is false, it will first output "Covid test", before calling the write method inside of the Patient class, which will insert the patient information into the ostream to be displayed on the console. Except csvWrite, all the other pure function methods have been improved, so we are making sure the compiler will be calling the latest and improved version of the method. 
For the TriagePatient module, which is also inherited from the Patient class. It contains all the properties that inherited from the Patient class, but also with more features, this class also contains the member variable that being dynamically allocated, m_symptoms, which stores the detailed symptoms of a triage patient. I have included setSymptoms and deallocate those private method to safely set the symtoms of the arriving patient for the triage centre. Same with CovidPatient module, this module also has one integer global variable called nextTriageTicket that being initialized to one. This global variable is also being used to determine the ticket number for the next triage Patient, same logic being used as in the CovidPatient module. I have also implemented the pure virtual function type that being inherited from the Patient class, and this time it is used to identifies the Patient object as a Triage patient, and it will return the character T. Also, csvWrite, csvRead, write and read those virtual functions have been implemented inside of this module as well. Same concepts being used in the Covid Patient module, but for this TriagePatient module, we also need to put in consideration of outputting and setting symptoms. All four functions being override and improved. I have also included utils module again to get the patient symptoms dynamically with the function that I have implemented, getcstr. 
Both testers being provided for each module have clearly shown the similarities and differences of their output, information being stored and functionalities. They have given me an opportunity to check if my data being stored and read properly, and also consolidate the logic of the program. 

Milestone 5: 
PreTriage is the final module that I have implemented, which includes the functionalities that is very related to the Pre-Triage Application actions that are closely relates to the Patients when they visit a hospital. For example, this module is able to create a lineup of patients and issues tickets for each of them as they arrive at the hospital, also, patients are able to be registered as Covid patient or a Triage Patient, their ticket number and up to date waiting time will be provided, ticket number is able to be called when they are being admitted to either the Covid testing center or the Triage center. We have data files that holds patients’ records being included in this module. The data file able to save all the patient information, and also, we can read/extract data from the data files as well. While Patient, CovidPatient, TriagePatient module are mainly focused on data of one patient, this module is used to deal with a maximum of 100 lineup patients. The class includes the average waiting Time objects for covid and triage patients. And also, an array of Patient pointers which holds either Covid or Triage Patient dynamically. The dynamically allocated character pointer that holds the name of the Patient data file, total numbers of patients, menu object to select Register or Admit, and the menu object that able to select the Patient type. 
First, I have made sure the all the member variables are being initialized to safe empty state except m_appMenu, m_pMenu, m_averCovidWait and m_averTriageWait are being initialized to their corresponding values. The Menu and Time object can be created with the two argument Menu constructor, and one argument Time constructor. load method is being implemented to load the data from the data file and stores them in the m_lineup array. We are creating an array of instances of Patients. But depends on what type of Patient they are, the object will be created accordingly. We have three different testers that test how many records being loaded in different situations, one is an existing data file but with no data being stored, another one is a small data file with 16 records, and also a data file with more than 100 records. The destructor of this class is used to open for output, and overwriting the content in file if it is already existing. After data being saved, I have deallocated each patient in the lineup, and the data filename dynamically. 
Also, the run method inside of the module is used to display the application menu and get the fool-proved integer selection from the user, I have used extraction operation that I have implemented inside of the Menu module. reg method is to register patient based on time, another Menu object will be displayed and we will get another selection based on the user selection for the type of patient they are to register. Depends on the type, patient type will be created accordingly. Inside of this function, we are able to set the arrival time for the patient by using setArrivalTime method that is inside of the Patient class, and extract patient information by using the extraction operator inside of the IOAble module. And using the latest read method based on type of object being created. For admit method, we also able to choose based on patient type, this method includes calling for next patient in line, and insert patient information to console, and remove the patient dynamically from the lineup. I have included the function template removeDynamicElement that being provided in the utils module, to be able to remove a patient from the line up when it is being admitted, and decrement the lineup size by one. 
For getWaitTime, I have used logic of whenever when we see a type match in the lineup of patients, we will increment the time by average waiting time based on their type. And then return a Time object with the wait time that I have been recorded in minutes as the argument. And for setAverageWaitTime, I have used the function being provided to calculate average time in minutes, and then create the temporary Time object and let it assign to the average time. 

Conclusion: 
The final project has provided me knowledge of the implementation logic and process. It contained all the information that I have learned during this semester, which has helped me understand more about using the learned knowledge from a real-world example like this. Also, I have created unit-testing, and using the tester programs that professor has provided which helped me limiting errors in a lot of situations, and keep memory being allocated properly, and information being stored and outputted properly as well. It was a challenging project, but by separating them into different modules, providing some hints based and thinking process on the instruction sheet, it has helped me learned so much more about how a good program should think. 

Note: 
I have implemented getcstr function without using the C++ string class. 
